const O=new URL("lib.wasm",import.meta.url);await(await fetch(O)).arrayBuffer();const W=!!globalThis.WorkerGlobalScope&&globalThis instanceof WorkerGlobalScope,G=async(a,P)=>{const e=crypto.getRandomValues(new Uint8Array(16)),b=new Uint8Array(await crypto.subtle.digest("SHA-256",e)).toHex(),f=await new Promise((l,i)=>{const n=new Worker(import.meta.url,{type:"module",credentials:"omit",name:`${b}-0`});n.onerror=y=>i(),n.onmessage=({data:y})=>{if(typeof y=="object"){const{hash:r,ready:o}=y;r===b&&o&&(n.onmessage=null,l(n))}}});return P.throwIfAborted(),await new Promise((l,i)=>{if(P.aborted)return i();f.onerror=n=>{f.postMessage({hash:b,terminate:!0}),f.terminate(),i()},P.addEventListener("abort",f.onerror),f.onmessage=({data:n})=>{if(typeof n=="object"){const{hash:y,proof:r}=n;y===b&&r&&(f.terminate(),l(r))}},f.postMessage({hash:b,nonce:a})})};export default G;if(W){const[a,P]=globalThis.name.split("-");let e;const{instance:b}=await WebAssembly.instantiateStreaming(fetch(O,{cache:"force-cache"}),{js:{println:(r,o)=>console.log(new TextDecoder().decode(new Uint8Array(e.memory.buffer,r,o))),eprintln:(r,o)=>console.error(new TextDecoder().decode(new Uint8Array(e.memory.buffer,r,o)))}});e=b.exports;const f=new DataView(e.memory.buffer,e.HASH_LENGTH_PTR,4).getUint32(0,!0),l=new DataView(e.memory.buffer,e.STEP_COUNT_PTR,4).getUint32(0,!0),i=new DataView(e.memory.buffer,e.BLOCK_SIZE_PTR,4).getUint32(0,!0),n=new DataView(e.memory.buffer,e.CHAIN_BLOCK_COUNT_PTR,4).getUint32(0,!0),y=new DataView(e.memory.buffer,e.CHAIN_COUNT_PTR,4).getUint32(0,!0);if(P==="0"){const r=u=>new Promise((g,T)=>{const s=new Worker(import.meta.url,{type:"module",credentials:"omit",name:`${a}-${u}`});s.onerror=c=>T(),s.onmessage=({data:c})=>{if(typeof c=="object"){const{hash:_,ready:h}=c;_===a&&h&&(s.onmessage=null,g(s))}}}),o=Promise.all(Array.from({length:y},(u,g)=>r(g+1)));onmessage=async({data:u})=>{if(typeof u=="object"){const{hash:g,terminate:T,nonce:s}=u;if(g===a){if(T)return(await o).forEach(c=>c.terminate()),globalThis.terminate();if(s instanceof Uint8Array){if(s.length!==16)throw new Error("nonce must be 16 bytes long");const c=await Promise.all((await o).map((t,w)=>new Promise((p,k)=>{t.onerror=A=>k();const m=new MessageChannel;m.port1.onmessage=({data:A})=>{m.port1.onmessage=null,p({hashChain:A,worker:t,channel:m})},t.postMessage({hash:a,nonce:s,n:w,port:m.port2},[m.port2])}))).catch(onerror),_=e.alloc_hash_chains();c.forEach(({hashChain:t},w)=>{const p=e.alloc_hash_chain();new Uint8Array(e.memory.buffer,p,n*f).set(t),new DataView(e.memory.buffer,_+w*4).setUint32(0,p,!0)});const h=e.build_state(_),d=e.root(h),U=e.select_indices(d),N=new Uint32Array(e.memory.buffer,U,l),C=e.alloc_blocks(),S=new Uint8Array(e.memory.buffer,C,l*i);for(let t=0;t<l;++t){const w=N[t]-1,p=Math.trunc(w/n),{worker:k,channel:m}=c[p],A=w%n,E=await new Promise(H=>{m.port1.onmessage=({data:I})=>{m.port1.onmessage=null,H(I)},k.postMessage({hash:a,index:A})});S.set(E,t*i)}const M=e.select_reference_indices(U,C),B=new Uint32Array(e.memory.buffer,M,l),x=e.alloc_blocks(),L=new Uint8Array(e.memory.buffer,x,l*i);for(let t=0;t<l;++t){const w=B[t],p=Math.trunc(w/n),{worker:k,channel:m}=c[p],A=w%n,E=await new Promise(H=>{m.port1.onmessage=({data:I})=>{m.port1.onmessage=null,H(I)},k.postMessage({hash:a,index:A})});L.set(E,t*i)}(await o).forEach(t=>t.terminate());const D=e.combine(h,d,U,M,C,x),[j,R]=new Uint32Array(e.memory.buffer,D,2),V=new Uint8Array(e.memory.buffer,j,R);postMessage({hash:a,proof:V})}}}}}else{let r,o;onmessage=async({data:u})=>{if(typeof u=="object"){const{hash:g,terminate:T,nonce:s,n:c,port:_,index:h}=u;if(g===a){if(T)return globalThis.terminate();if(_&&s instanceof Uint8Array){const d=parseInt(c);if(s.length!==16||isNaN(d)||d<0||d>=y)throw new Error;o=_;const U=e.alloc_nonce();new Uint8Array(e.memory.buffer,U,16).set(s),r=e.generate_chain(d,U),e.free_nonce(U,16);const N=e.hash_chain(r),C=new Uint8Array(e.memory.buffer,N,n*f);o.postMessage(C)}else!isNaN(h)&&h>0&&h<n&&o.postMessage(new Uint8Array(e.memory.buffer,r+h*i,i))}}}}postMessage({hash:a,ready:!0})}